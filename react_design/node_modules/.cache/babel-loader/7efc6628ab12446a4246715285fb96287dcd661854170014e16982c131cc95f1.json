{"ast":null,"code":"'use strict';\n\nvar UPPER32 = Math.pow(2, 32);\nvar warnedPrecision = false;\nfunction warnPrecision() {\n  if (!warnedPrecision) {\n    warnedPrecision = true;\n    console.warn('CBOR 64-bit integer array values may lose precision. No further warnings.');\n  }\n}\n\n/**\r\n * Unpack 64-bit unsigned integer from byte array.\r\n * @param {Uint8Array} bytes\r\n*/\nfunction decodeUint64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = uint32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n  return arr;\n}\n\n/**\r\n * Unpack 64-bit signed integer from byte array.\r\n * @param {Uint8Array} bytes\r\n*/\nfunction decodeInt64LE(bytes) {\n  warnPrecision();\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var arrLen = byteLen / 8;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  var uint32View = new Uint32Array(buffer);\n  var int32View = new Int32Array(buffer);\n  var arr = new Array(arrLen);\n  for (var i = 0; i < arrLen; i++) {\n    var si = i * 2;\n    var lo = uint32View[si];\n    var hi = int32View[si + 1];\n    arr[i] = lo + UPPER32 * hi;\n  }\n  return arr;\n}\n\n/**\r\n * Unpack typed array from byte array.\r\n * @param {Uint8Array} bytes\r\n * @param {type} ArrayType - Desired output array type\r\n*/\nfunction decodeNativeArray(bytes, ArrayType) {\n  var byteLen = bytes.byteLength;\n  var offset = bytes.byteOffset;\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\n  return new ArrayType(buffer);\n}\n\n/**\r\n * Supports a subset of draft CBOR typed array tags:\r\n *     <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>\r\n *\r\n * Only supports little-endian tags for now.\r\n */\nvar nativeArrayTypes = {\n  64: Uint8Array,\n  69: Uint16Array,\n  70: Uint32Array,\n  72: Int8Array,\n  77: Int16Array,\n  78: Int32Array,\n  85: Float32Array,\n  86: Float64Array\n};\n\n/**\r\n * We can also decode 64-bit integer arrays, since ROS has these types.\r\n */\nvar conversionArrayTypes = {\n  71: decodeUint64LE,\n  79: decodeInt64LE\n};\n\n/**\r\n * Handle CBOR typed array tags during decoding.\r\n * @param {Uint8Array} data\r\n * @param {Number} tag\r\n */\nfunction cborTypedArrayTagger(data, tag) {\n  if (tag in nativeArrayTypes) {\n    var arrayType = nativeArrayTypes[tag];\n    return decodeNativeArray(data, arrayType);\n  }\n  if (tag in conversionArrayTypes) {\n    return conversionArrayTypes[tag](data);\n  }\n  return data;\n}\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = cborTypedArrayTagger;\n}","map":{"version":3,"names":["UPPER32","Math","pow","warnedPrecision","warnPrecision","console","warn","decodeUint64LE","bytes","byteLen","byteLength","offset","byteOffset","arrLen","buffer","slice","uint32View","Uint32Array","arr","Array","i","si","lo","hi","decodeInt64LE","int32View","Int32Array","decodeNativeArray","ArrayType","nativeArrayTypes","Uint8Array","Uint16Array","Int8Array","Int16Array","Float32Array","Float64Array","conversionArrayTypes","cborTypedArrayTagger","data","tag","arrayType","module","exports"],"sources":["C:/git/Ui_design/react_design/node_modules/roslib/src/util/cborTypedArrayTags.js"],"sourcesContent":["'use strict';\r\n\r\nvar UPPER32 = Math.pow(2, 32);\r\n\r\nvar warnedPrecision = false;\r\nfunction warnPrecision() {\r\n  if (!warnedPrecision) {\r\n    warnedPrecision = true;\r\n    console.warn('CBOR 64-bit integer array values may lose precision. No further warnings.');\r\n  }\r\n}\r\n\r\n/**\r\n * Unpack 64-bit unsigned integer from byte array.\r\n * @param {Uint8Array} bytes\r\n*/\r\nfunction decodeUint64LE(bytes) {\r\n  warnPrecision();\r\n\r\n  var byteLen = bytes.byteLength;\r\n  var offset = bytes.byteOffset;\r\n  var arrLen = byteLen / 8;\r\n\r\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\r\n  var uint32View = new Uint32Array(buffer);\r\n\r\n  var arr = new Array(arrLen);\r\n  for (var i = 0; i < arrLen; i++) {\r\n    var si = i * 2;\r\n    var lo = uint32View[si];\r\n    var hi = uint32View[si+1];\r\n    arr[i] = lo + UPPER32 * hi;\r\n  }\r\n\r\n  return arr;\r\n}\r\n\r\n/**\r\n * Unpack 64-bit signed integer from byte array.\r\n * @param {Uint8Array} bytes\r\n*/\r\nfunction decodeInt64LE(bytes) {\r\n  warnPrecision();\r\n\r\n  var byteLen = bytes.byteLength;\r\n  var offset = bytes.byteOffset;\r\n  var arrLen = byteLen / 8;\r\n\r\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\r\n  var uint32View = new Uint32Array(buffer);\r\n  var int32View = new Int32Array(buffer);\r\n\r\n  var arr = new Array(arrLen);\r\n  for (var i = 0; i < arrLen; i++) {\r\n    var si = i * 2;\r\n    var lo = uint32View[si];\r\n    var hi = int32View[si+1];\r\n    arr[i] = lo + UPPER32 * hi;\r\n  }\r\n\r\n  return arr;\r\n}\r\n\r\n/**\r\n * Unpack typed array from byte array.\r\n * @param {Uint8Array} bytes\r\n * @param {type} ArrayType - Desired output array type\r\n*/\r\nfunction decodeNativeArray(bytes, ArrayType) {\r\n  var byteLen = bytes.byteLength;\r\n  var offset = bytes.byteOffset;\r\n  var buffer = bytes.buffer.slice(offset, offset + byteLen);\r\n  return new ArrayType(buffer);\r\n}\r\n\r\n/**\r\n * Supports a subset of draft CBOR typed array tags:\r\n *     <https://tools.ietf.org/html/draft-ietf-cbor-array-tags-00>\r\n *\r\n * Only supports little-endian tags for now.\r\n */\r\nvar nativeArrayTypes = {\r\n  64: Uint8Array,\r\n  69: Uint16Array,\r\n  70: Uint32Array,\r\n  72: Int8Array,\r\n  77: Int16Array,\r\n  78: Int32Array,\r\n  85: Float32Array,\r\n  86: Float64Array\r\n};\r\n\r\n/**\r\n * We can also decode 64-bit integer arrays, since ROS has these types.\r\n */\r\nvar conversionArrayTypes = {\r\n  71: decodeUint64LE,\r\n  79: decodeInt64LE\r\n};\r\n\r\n/**\r\n * Handle CBOR typed array tags during decoding.\r\n * @param {Uint8Array} data\r\n * @param {Number} tag\r\n */\r\nfunction cborTypedArrayTagger(data, tag) {\r\n  if (tag in nativeArrayTypes) {\r\n    var arrayType = nativeArrayTypes[tag];\r\n    return decodeNativeArray(data, arrayType);\r\n  }\r\n  if (tag in conversionArrayTypes) {\r\n    return conversionArrayTypes[tag](data);\r\n  }\r\n  return data;\r\n}\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = cborTypedArrayTagger;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}